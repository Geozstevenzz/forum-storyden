package bindings

import (
	"context"

	"github.com/Southclaws/fault"
	"github.com/Southclaws/fault/fctx"
	"github.com/Southclaws/fault/ftag"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/getkin/kin-openapi/openapi3filter"
	"github.com/labstack/echo/v4"
	echomiddleware "github.com/oapi-codegen/echo-middleware"
	"github.com/samber/lo"

	"github.com/Southclaws/storyden/app/resources/account/account_querier"
	"github.com/Southclaws/storyden/app/resources/rbac"
	"github.com/Southclaws/storyden/app/services/authentication/session"
	"github.com/Southclaws/storyden/app/transports/http/bindings/openapi_rbac"
)

type Authorisation struct {
	accountQuery *account_querier.Querier
}

func newAuthorisation(aq *account_querier.Querier) *Authorisation {
	return &Authorisation{accountQuery: aq}
}

func (i *Authorisation) validator(oapictx context.Context, ai *openapi3filter.AuthenticationInput) error {
	op := ai.RequestValidationInput.Route.Operation.OperationID
	ctx := ai.RequestValidationInput.Request.Context()

	requestSecurityScheme, err := session.GetSecurityScheme(ctx)
	if err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}

	allowedSecuritySchemes := ai.RequestValidationInput.Route.Operation.Security

	// If the route defines a set of security schemes, ensure the one used by
	// the request exists in the list. If not, reject the request entirely. A
	// quirk of the OpenAPI runtime is it calls this validator for every scheme
	// defined in the spec, so this function gets called multiple times which is
	// not amazing for performance but... whatadayagonnado? Early exit at least.
	if allowedSecuritySchemes != nil {
		matchSecurityScheme := lo.ContainsBy(*allowedSecuritySchemes, func(sr openapi3.SecurityRequirement) bool {
			return lo.HasKey(sr, requestSecurityScheme)
		})
		if !matchSecurityScheme {
			return fault.New("invalid security scheme for operation", fctx.With(ctx), ftag.With(ftag.PermissionDenied))
		}
	}

	sessionRequired, perm := GetPermissionForOperation(op)
	if perm == nil {
		// No specific permission required, just need a session.
		return nil
	}

	// NOTE: These are the security schemes defined in the OpenAPI spec under
	// `securitySchemes` - they aren't generated by the codegen so be careful.
	switch ai.SecuritySchemeName {
	case "access_key":
	case "browser":
		// TODO: Validate which session type is being used
	case "webauthn":
		if sessionRequired {
			// TODO: Handle more gracefully
			panic("unexpected security scheme for session-required operation: " + ai.SecuritySchemeName)
		}
	}

	c := oapictx.Value(echomiddleware.EchoContextKey).(echo.Context)

	// If the request was by an account, reject any requests if suspended. Yes
	// they can log out to *view* content (if default/guest permissions allow)
	// but this is an easy way to apply suspension logic to all operations.
	acc, ok := session.GetOptAccount(c.Request().Context()).Get()
	if ok {
		if err := acc.RejectSuspended(); err != nil {
			return fault.Wrap(err, fctx.With(ctx))
		}
	} else if sessionRequired {
		// If the operation requires a session but no account is present, then
		// reject with an Unauthenticated error which maps to 401 Unauthorized.
		return fault.New("session required for operation", fctx.With(ctx), ftag.With(ftag.Unauthenticated))
	}

	if err := session.Authorise(ctx, nil, *perm, rbac.PermissionAdministrator); err != nil {
		return fault.New("required role not held", fctx.With(ctx), ftag.With(ftag.PermissionDenied))
	}

	return nil
}

// TODO: Use Scopes field of OpenAPI security spec.
//
// GetPermissionForOperation maps an operation ID to a permission requirement.
// Most operations are quite simple and just require a permission to operate but
// other operations have special requirements that are implemented elsewhere.
//
// There are three kinds of return state from this check function:
// 1. Publicly accessible with no account (false, nil)
// 2. Requires a session but no specific permission (true, nil)
// 3. Requires a specific permission (true, rbac.Permission{...})
//
// NOTE: Some operations are checked in the service layer instead of here due to
// additional logic required to determine attributes such as resource ownership.
func GetPermissionForOperation(operationID string) (requiresSession bool, requiresPermission *rbac.Permission) {
	return openapi_rbac.GetOperationPermission(&openapi_rbac.Mapping{}, operationID)
}
