// Code generated by entc, DO NOT EDIT.

package model

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/Southclaws/storyden/api/src/infra/db/model/category"
	"github.com/Southclaws/storyden/api/src/infra/db/model/notification"
	"github.com/Southclaws/storyden/api/src/infra/db/model/post"
	"github.com/Southclaws/storyden/api/src/infra/db/model/predicate"
	"github.com/Southclaws/storyden/api/src/infra/db/model/react"
	"github.com/Southclaws/storyden/api/src/infra/db/model/rule"
	"github.com/Southclaws/storyden/api/src/infra/db/model/server"
	"github.com/Southclaws/storyden/api/src/infra/db/model/subscription"
	"github.com/Southclaws/storyden/api/src/infra/db/model/tag"
	"github.com/Southclaws/storyden/api/src/infra/db/model/user"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCategory     = "Category"
	TypeNotification = "Notification"
	TypePost         = "Post"
	TypeReact        = "React"
	TypeRule         = "Rule"
	TypeServer       = "Server"
	TypeSubscription = "Subscription"
	TypeTag          = "Tag"
	TypeUser         = "User"
)

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	description   *string
	colour        *string
	sort          *int
	addsort       *int
	admin         *bool
	clearedFields map[string]struct{}
	posts         map[uuid.UUID]struct{}
	removedposts  map[uuid.UUID]struct{}
	clearedposts  bool
	done          bool
	oldValue      func(context.Context) (*Category, error)
	predicates    []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id string) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
}

// SetColour sets the "colour" field.
func (m *CategoryMutation) SetColour(s string) {
	m.colour = &s
}

// Colour returns the value of the "colour" field in the mutation.
func (m *CategoryMutation) Colour() (r string, exists bool) {
	v := m.colour
	if v == nil {
		return
	}
	return *v, true
}

// OldColour returns the old "colour" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldColour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColour: %w", err)
	}
	return oldValue.Colour, nil
}

// ResetColour resets all changes to the "colour" field.
func (m *CategoryMutation) ResetColour() {
	m.colour = nil
}

// SetSort sets the "sort" field.
func (m *CategoryMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *CategoryMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *CategoryMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *CategoryMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *CategoryMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetAdmin sets the "admin" field.
func (m *CategoryMutation) SetAdmin(b bool) {
	m.admin = &b
}

// Admin returns the value of the "admin" field in the mutation.
func (m *CategoryMutation) Admin() (r bool, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "admin" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "admin" field.
func (m *CategoryMutation) ResetAdmin() {
	m.admin = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *CategoryMutation) AddPostIDs(ids ...uuid.UUID) {
	if m.posts == nil {
		m.posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *CategoryMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *CategoryMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *CategoryMutation) RemovePostIDs(ids ...uuid.UUID) {
	if m.removedposts == nil {
		m.removedposts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *CategoryMutation) RemovedPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *CategoryMutation) PostsIDs() (ids []uuid.UUID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *CategoryMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.colour != nil {
		fields = append(fields, category.FieldColour)
	}
	if m.sort != nil {
		fields = append(fields, category.FieldSort)
	}
	if m.admin != nil {
		fields = append(fields, category.FieldAdmin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	case category.FieldColour:
		return m.Colour()
	case category.FieldSort:
		return m.Sort()
	case category.FieldAdmin:
		return m.Admin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldColour:
		return m.OldColour(ctx)
	case category.FieldSort:
		return m.OldSort(ctx)
	case category.FieldAdmin:
		return m.OldAdmin(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldColour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColour(v)
		return nil
	case category.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case category.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, category.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldColour:
		m.ResetColour()
		return nil
	case category.FieldSort:
		m.ResetSort()
		return nil
	case category.FieldAdmin:
		m.ResetAdmin()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.posts != nil {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedposts != nil {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedposts {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	title               *string
	description         *string
	link                *string
	read                *bool
	createdAt           *time.Time
	subscriptionId      *string
	clearedFields       map[string]struct{}
	subscription        map[string]struct{}
	removedsubscription map[string]struct{}
	clearedsubscription bool
	done                bool
	oldValue            func(context.Context) (*Notification, error)
	predicates          []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id string) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *NotificationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotificationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NotificationMutation) ResetDescription() {
	m.description = nil
}

// SetLink sets the "link" field.
func (m *NotificationMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *NotificationMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *NotificationMutation) ResetLink() {
	m.link = nil
}

// SetRead sets the "read" field.
func (m *NotificationMutation) SetRead(b bool) {
	m.read = &b
}

// Read returns the value of the "read" field in the mutation.
func (m *NotificationMutation) Read() (r bool, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old "read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// ResetRead resets all changes to the "read" field.
func (m *NotificationMutation) ResetRead() {
	m.read = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetSubscriptionId sets the "subscriptionId" field.
func (m *NotificationMutation) SetSubscriptionId(s string) {
	m.subscriptionId = &s
}

// SubscriptionId returns the value of the "subscriptionId" field in the mutation.
func (m *NotificationMutation) SubscriptionId() (r string, exists bool) {
	v := m.subscriptionId
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionId returns the old "subscriptionId" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSubscriptionId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionId: %w", err)
	}
	return oldValue.SubscriptionId, nil
}

// ResetSubscriptionId resets all changes to the "subscriptionId" field.
func (m *NotificationMutation) ResetSubscriptionId() {
	m.subscriptionId = nil
}

// AddSubscriptionIDs adds the "subscription" edge to the Subscription entity by ids.
func (m *NotificationMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscription == nil {
		m.subscription = make(map[string]struct{})
	}
	for i := range ids {
		m.subscription[ids[i]] = struct{}{}
	}
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *NotificationMutation) ClearSubscription() {
	m.clearedsubscription = true
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *NotificationMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// RemoveSubscriptionIDs removes the "subscription" edge to the Subscription entity by IDs.
func (m *NotificationMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscription == nil {
		m.removedsubscription = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscription, ids[i])
		m.removedsubscription[ids[i]] = struct{}{}
	}
}

// RemovedSubscription returns the removed IDs of the "subscription" edge to the Subscription entity.
func (m *NotificationMutation) RemovedSubscriptionIDs() (ids []string) {
	for id := range m.removedsubscription {
		ids = append(ids, id)
	}
	return
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
func (m *NotificationMutation) SubscriptionIDs() (ids []string) {
	for id := range m.subscription {
		ids = append(ids, id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *NotificationMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
	m.removedsubscription = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, notification.FieldDescription)
	}
	if m.link != nil {
		fields = append(fields, notification.FieldLink)
	}
	if m.read != nil {
		fields = append(fields, notification.FieldRead)
	}
	if m.createdAt != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.subscriptionId != nil {
		fields = append(fields, notification.FieldSubscriptionId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldDescription:
		return m.Description()
	case notification.FieldLink:
		return m.Link()
	case notification.FieldRead:
		return m.Read()
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldSubscriptionId:
		return m.SubscriptionId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldDescription:
		return m.OldDescription(ctx)
	case notification.FieldLink:
		return m.OldLink(ctx)
	case notification.FieldRead:
		return m.OldRead(ctx)
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldSubscriptionId:
		return m.OldSubscriptionId(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notification.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case notification.FieldRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldSubscriptionId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionId(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldDescription:
		m.ResetDescription()
		return nil
	case notification.FieldLink:
		m.ResetLink()
		return nil
	case notification.FieldRead:
		m.ResetRead()
		return nil
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldSubscriptionId:
		m.ResetSubscriptionId()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscription != nil {
		edges = append(edges, notification.EdgeSubscription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeSubscription:
		ids := make([]ent.Value, 0, len(m.subscription))
		for id := range m.subscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubscription != nil {
		edges = append(edges, notification.EdgeSubscription)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeSubscription:
		ids := make([]ent.Value, 0, len(m.removedsubscription))
		for id := range m.removedsubscription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscription {
		edges = append(edges, notification.EdgeSubscription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeSubscription:
		return m.clearedsubscription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeSubscription:
		m.ResetSubscription()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	title           *string
	slug            *string
	body            *string
	short           *string
	first           *bool
	pinned          *bool
	createdAt       *time.Time
	updatedAt       *time.Time
	deletedAt       *time.Time
	rootPostId      *string
	replyPostId     *string
	categoryId      *string
	clearedFields   map[string]struct{}
	author          *uuid.UUID
	clearedauthor   bool
	category        map[string]struct{}
	removedcategory map[string]struct{}
	clearedcategory bool
	tags            map[uuid.UUID]struct{}
	removedtags     map[uuid.UUID]struct{}
	clearedtags     bool
	root            map[uuid.UUID]struct{}
	removedroot     map[uuid.UUID]struct{}
	clearedroot     bool
	posts           map[uuid.UUID]struct{}
	removedposts    map[uuid.UUID]struct{}
	clearedposts    bool
	replies         map[uuid.UUID]struct{}
	removedreplies  map[uuid.UUID]struct{}
	clearedreplies  bool
	replyTo         map[uuid.UUID]struct{}
	removedreplyTo  map[uuid.UUID]struct{}
	clearedreplyTo  bool
	reacts          map[string]struct{}
	removedreacts   map[string]struct{}
	clearedreacts   bool
	done            bool
	oldValue        func(context.Context) (*Post, error)
	predicates      []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id uuid.UUID) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PostMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[post.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PostMutation) TitleCleared() bool {
	_, ok := m.clearedFields[post.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, post.FieldTitle)
}

// SetSlug sets the "slug" field.
func (m *PostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[post.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostMutation) SlugCleared() bool {
	_, ok := m.clearedFields[post.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, post.FieldSlug)
}

// SetBody sets the "body" field.
func (m *PostMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *PostMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *PostMutation) ResetBody() {
	m.body = nil
}

// SetShort sets the "short" field.
func (m *PostMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *PostMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *PostMutation) ResetShort() {
	m.short = nil
}

// SetFirst sets the "first" field.
func (m *PostMutation) SetFirst(b bool) {
	m.first = &b
}

// First returns the value of the "first" field in the mutation.
func (m *PostMutation) First() (r bool, exists bool) {
	v := m.first
	if v == nil {
		return
	}
	return *v, true
}

// OldFirst returns the old "first" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldFirst(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirst: %w", err)
	}
	return oldValue.First, nil
}

// ResetFirst resets all changes to the "first" field.
func (m *PostMutation) ResetFirst() {
	m.first = nil
}

// SetPinned sets the "pinned" field.
func (m *PostMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *PostMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *PostMutation) ResetPinned() {
	m.pinned = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *PostMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *PostMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *PostMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *PostMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[post.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *PostMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *PostMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, post.FieldDeletedAt)
}

// SetRootPostId sets the "rootPostId" field.
func (m *PostMutation) SetRootPostId(s string) {
	m.rootPostId = &s
}

// RootPostId returns the value of the "rootPostId" field in the mutation.
func (m *PostMutation) RootPostId() (r string, exists bool) {
	v := m.rootPostId
	if v == nil {
		return
	}
	return *v, true
}

// OldRootPostId returns the old "rootPostId" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldRootPostId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootPostId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootPostId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootPostId: %w", err)
	}
	return oldValue.RootPostId, nil
}

// ClearRootPostId clears the value of the "rootPostId" field.
func (m *PostMutation) ClearRootPostId() {
	m.rootPostId = nil
	m.clearedFields[post.FieldRootPostId] = struct{}{}
}

// RootPostIdCleared returns if the "rootPostId" field was cleared in this mutation.
func (m *PostMutation) RootPostIdCleared() bool {
	_, ok := m.clearedFields[post.FieldRootPostId]
	return ok
}

// ResetRootPostId resets all changes to the "rootPostId" field.
func (m *PostMutation) ResetRootPostId() {
	m.rootPostId = nil
	delete(m.clearedFields, post.FieldRootPostId)
}

// SetReplyPostId sets the "replyPostId" field.
func (m *PostMutation) SetReplyPostId(s string) {
	m.replyPostId = &s
}

// ReplyPostId returns the value of the "replyPostId" field in the mutation.
func (m *PostMutation) ReplyPostId() (r string, exists bool) {
	v := m.replyPostId
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyPostId returns the old "replyPostId" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldReplyPostId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyPostId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyPostId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyPostId: %w", err)
	}
	return oldValue.ReplyPostId, nil
}

// ClearReplyPostId clears the value of the "replyPostId" field.
func (m *PostMutation) ClearReplyPostId() {
	m.replyPostId = nil
	m.clearedFields[post.FieldReplyPostId] = struct{}{}
}

// ReplyPostIdCleared returns if the "replyPostId" field was cleared in this mutation.
func (m *PostMutation) ReplyPostIdCleared() bool {
	_, ok := m.clearedFields[post.FieldReplyPostId]
	return ok
}

// ResetReplyPostId resets all changes to the "replyPostId" field.
func (m *PostMutation) ResetReplyPostId() {
	m.replyPostId = nil
	delete(m.clearedFields, post.FieldReplyPostId)
}

// SetCategoryId sets the "categoryId" field.
func (m *PostMutation) SetCategoryId(s string) {
	m.categoryId = &s
}

// CategoryId returns the value of the "categoryId" field in the mutation.
func (m *PostMutation) CategoryId() (r string, exists bool) {
	v := m.categoryId
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryId returns the old "categoryId" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCategoryId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryId: %w", err)
	}
	return oldValue.CategoryId, nil
}

// ClearCategoryId clears the value of the "categoryId" field.
func (m *PostMutation) ClearCategoryId() {
	m.categoryId = nil
	m.clearedFields[post.FieldCategoryId] = struct{}{}
}

// CategoryIdCleared returns if the "categoryId" field was cleared in this mutation.
func (m *PostMutation) CategoryIdCleared() bool {
	_, ok := m.clearedFields[post.FieldCategoryId]
	return ok
}

// ResetCategoryId resets all changes to the "categoryId" field.
func (m *PostMutation) ResetCategoryId() {
	m.categoryId = nil
	delete(m.clearedFields, post.FieldCategoryId)
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *PostMutation) SetAuthorID(id uuid.UUID) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *PostMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *PostMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *PostMutation) AuthorID() (id uuid.UUID, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *PostMutation) AuthorIDs() (ids []uuid.UUID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *PostMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// AddCategoryIDs adds the "category" edge to the Category entity by ids.
func (m *PostMutation) AddCategoryIDs(ids ...string) {
	if m.category == nil {
		m.category = make(map[string]struct{})
	}
	for i := range ids {
		m.category[ids[i]] = struct{}{}
	}
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *PostMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *PostMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// RemoveCategoryIDs removes the "category" edge to the Category entity by IDs.
func (m *PostMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategory == nil {
		m.removedcategory = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.category, ids[i])
		m.removedcategory[ids[i]] = struct{}{}
	}
}

// RemovedCategory returns the removed IDs of the "category" edge to the Category entity.
func (m *PostMutation) RemovedCategoryIDs() (ids []string) {
	for id := range m.removedcategory {
		ids = append(ids, id)
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
func (m *PostMutation) CategoryIDs() (ids []string) {
	for id := range m.category {
		ids = append(ids, id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *PostMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
	m.removedcategory = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *PostMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *PostMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *PostMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *PostMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *PostMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *PostMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *PostMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddRootIDs adds the "root" edge to the Post entity by ids.
func (m *PostMutation) AddRootIDs(ids ...uuid.UUID) {
	if m.root == nil {
		m.root = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.root[ids[i]] = struct{}{}
	}
}

// ClearRoot clears the "root" edge to the Post entity.
func (m *PostMutation) ClearRoot() {
	m.clearedroot = true
}

// RootCleared reports if the "root" edge to the Post entity was cleared.
func (m *PostMutation) RootCleared() bool {
	return m.clearedroot
}

// RemoveRootIDs removes the "root" edge to the Post entity by IDs.
func (m *PostMutation) RemoveRootIDs(ids ...uuid.UUID) {
	if m.removedroot == nil {
		m.removedroot = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.root, ids[i])
		m.removedroot[ids[i]] = struct{}{}
	}
}

// RemovedRoot returns the removed IDs of the "root" edge to the Post entity.
func (m *PostMutation) RemovedRootIDs() (ids []uuid.UUID) {
	for id := range m.removedroot {
		ids = append(ids, id)
	}
	return
}

// RootIDs returns the "root" edge IDs in the mutation.
func (m *PostMutation) RootIDs() (ids []uuid.UUID) {
	for id := range m.root {
		ids = append(ids, id)
	}
	return
}

// ResetRoot resets all changes to the "root" edge.
func (m *PostMutation) ResetRoot() {
	m.root = nil
	m.clearedroot = false
	m.removedroot = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *PostMutation) AddPostIDs(ids ...uuid.UUID) {
	if m.posts == nil {
		m.posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *PostMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *PostMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *PostMutation) RemovePostIDs(ids ...uuid.UUID) {
	if m.removedposts == nil {
		m.removedposts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *PostMutation) RemovedPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *PostMutation) PostsIDs() (ids []uuid.UUID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *PostMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddReplyIDs adds the "replies" edge to the Post entity by ids.
func (m *PostMutation) AddReplyIDs(ids ...uuid.UUID) {
	if m.replies == nil {
		m.replies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Post entity.
func (m *PostMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Post entity was cleared.
func (m *PostMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Post entity by IDs.
func (m *PostMutation) RemoveReplyIDs(ids ...uuid.UUID) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Post entity.
func (m *PostMutation) RemovedRepliesIDs() (ids []uuid.UUID) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *PostMutation) RepliesIDs() (ids []uuid.UUID) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *PostMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// AddReplyToIDs adds the "replyTo" edge to the Post entity by ids.
func (m *PostMutation) AddReplyToIDs(ids ...uuid.UUID) {
	if m.replyTo == nil {
		m.replyTo = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.replyTo[ids[i]] = struct{}{}
	}
}

// ClearReplyTo clears the "replyTo" edge to the Post entity.
func (m *PostMutation) ClearReplyTo() {
	m.clearedreplyTo = true
}

// ReplyToCleared reports if the "replyTo" edge to the Post entity was cleared.
func (m *PostMutation) ReplyToCleared() bool {
	return m.clearedreplyTo
}

// RemoveReplyToIDs removes the "replyTo" edge to the Post entity by IDs.
func (m *PostMutation) RemoveReplyToIDs(ids ...uuid.UUID) {
	if m.removedreplyTo == nil {
		m.removedreplyTo = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.replyTo, ids[i])
		m.removedreplyTo[ids[i]] = struct{}{}
	}
}

// RemovedReplyTo returns the removed IDs of the "replyTo" edge to the Post entity.
func (m *PostMutation) RemovedReplyToIDs() (ids []uuid.UUID) {
	for id := range m.removedreplyTo {
		ids = append(ids, id)
	}
	return
}

// ReplyToIDs returns the "replyTo" edge IDs in the mutation.
func (m *PostMutation) ReplyToIDs() (ids []uuid.UUID) {
	for id := range m.replyTo {
		ids = append(ids, id)
	}
	return
}

// ResetReplyTo resets all changes to the "replyTo" edge.
func (m *PostMutation) ResetReplyTo() {
	m.replyTo = nil
	m.clearedreplyTo = false
	m.removedreplyTo = nil
}

// AddReactIDs adds the "reacts" edge to the React entity by ids.
func (m *PostMutation) AddReactIDs(ids ...string) {
	if m.reacts == nil {
		m.reacts = make(map[string]struct{})
	}
	for i := range ids {
		m.reacts[ids[i]] = struct{}{}
	}
}

// ClearReacts clears the "reacts" edge to the React entity.
func (m *PostMutation) ClearReacts() {
	m.clearedreacts = true
}

// ReactsCleared reports if the "reacts" edge to the React entity was cleared.
func (m *PostMutation) ReactsCleared() bool {
	return m.clearedreacts
}

// RemoveReactIDs removes the "reacts" edge to the React entity by IDs.
func (m *PostMutation) RemoveReactIDs(ids ...string) {
	if m.removedreacts == nil {
		m.removedreacts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reacts, ids[i])
		m.removedreacts[ids[i]] = struct{}{}
	}
}

// RemovedReacts returns the removed IDs of the "reacts" edge to the React entity.
func (m *PostMutation) RemovedReactsIDs() (ids []string) {
	for id := range m.removedreacts {
		ids = append(ids, id)
	}
	return
}

// ReactsIDs returns the "reacts" edge IDs in the mutation.
func (m *PostMutation) ReactsIDs() (ids []string) {
	for id := range m.reacts {
		ids = append(ids, id)
	}
	return
}

// ResetReacts resets all changes to the "reacts" edge.
func (m *PostMutation) ResetReacts() {
	m.reacts = nil
	m.clearedreacts = false
	m.removedreacts = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, post.FieldSlug)
	}
	if m.body != nil {
		fields = append(fields, post.FieldBody)
	}
	if m.short != nil {
		fields = append(fields, post.FieldShort)
	}
	if m.first != nil {
		fields = append(fields, post.FieldFirst)
	}
	if m.pinned != nil {
		fields = append(fields, post.FieldPinned)
	}
	if m.createdAt != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, post.FieldDeletedAt)
	}
	if m.rootPostId != nil {
		fields = append(fields, post.FieldRootPostId)
	}
	if m.replyPostId != nil {
		fields = append(fields, post.FieldReplyPostId)
	}
	if m.categoryId != nil {
		fields = append(fields, post.FieldCategoryId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldTitle:
		return m.Title()
	case post.FieldSlug:
		return m.Slug()
	case post.FieldBody:
		return m.Body()
	case post.FieldShort:
		return m.Short()
	case post.FieldFirst:
		return m.First()
	case post.FieldPinned:
		return m.Pinned()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldDeletedAt:
		return m.DeletedAt()
	case post.FieldRootPostId:
		return m.RootPostId()
	case post.FieldReplyPostId:
		return m.ReplyPostId()
	case post.FieldCategoryId:
		return m.CategoryId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldSlug:
		return m.OldSlug(ctx)
	case post.FieldBody:
		return m.OldBody(ctx)
	case post.FieldShort:
		return m.OldShort(ctx)
	case post.FieldFirst:
		return m.OldFirst(ctx)
	case post.FieldPinned:
		return m.OldPinned(ctx)
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case post.FieldRootPostId:
		return m.OldRootPostId(ctx)
	case post.FieldReplyPostId:
		return m.OldReplyPostId(ctx)
	case post.FieldCategoryId:
		return m.OldCategoryId(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case post.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case post.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case post.FieldFirst:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirst(v)
		return nil
	case post.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case post.FieldRootPostId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootPostId(v)
		return nil
	case post.FieldReplyPostId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyPostId(v)
		return nil
	case post.FieldCategoryId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryId(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldTitle) {
		fields = append(fields, post.FieldTitle)
	}
	if m.FieldCleared(post.FieldSlug) {
		fields = append(fields, post.FieldSlug)
	}
	if m.FieldCleared(post.FieldDeletedAt) {
		fields = append(fields, post.FieldDeletedAt)
	}
	if m.FieldCleared(post.FieldRootPostId) {
		fields = append(fields, post.FieldRootPostId)
	}
	if m.FieldCleared(post.FieldReplyPostId) {
		fields = append(fields, post.FieldReplyPostId)
	}
	if m.FieldCleared(post.FieldCategoryId) {
		fields = append(fields, post.FieldCategoryId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldTitle:
		m.ClearTitle()
		return nil
	case post.FieldSlug:
		m.ClearSlug()
		return nil
	case post.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case post.FieldRootPostId:
		m.ClearRootPostId()
		return nil
	case post.FieldReplyPostId:
		m.ClearReplyPostId()
		return nil
	case post.FieldCategoryId:
		m.ClearCategoryId()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldSlug:
		m.ResetSlug()
		return nil
	case post.FieldBody:
		m.ResetBody()
		return nil
	case post.FieldShort:
		m.ResetShort()
		return nil
	case post.FieldFirst:
		m.ResetFirst()
		return nil
	case post.FieldPinned:
		m.ResetPinned()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case post.FieldRootPostId:
		m.ResetRootPostId()
		return nil
	case post.FieldReplyPostId:
		m.ResetReplyPostId()
		return nil
	case post.FieldCategoryId:
		m.ResetCategoryId()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.author != nil {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.category != nil {
		edges = append(edges, post.EdgeCategory)
	}
	if m.tags != nil {
		edges = append(edges, post.EdgeTags)
	}
	if m.root != nil {
		edges = append(edges, post.EdgeRoot)
	}
	if m.posts != nil {
		edges = append(edges, post.EdgePosts)
	}
	if m.replies != nil {
		edges = append(edges, post.EdgeReplies)
	}
	if m.replyTo != nil {
		edges = append(edges, post.EdgeReplyTo)
	}
	if m.reacts != nil {
		edges = append(edges, post.EdgeReacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.category))
		for id := range m.category {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeRoot:
		ids := make([]ent.Value, 0, len(m.root))
		for id := range m.root {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReplyTo:
		ids := make([]ent.Value, 0, len(m.replyTo))
		for id := range m.replyTo {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.reacts))
		for id := range m.reacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcategory != nil {
		edges = append(edges, post.EdgeCategory)
	}
	if m.removedtags != nil {
		edges = append(edges, post.EdgeTags)
	}
	if m.removedroot != nil {
		edges = append(edges, post.EdgeRoot)
	}
	if m.removedposts != nil {
		edges = append(edges, post.EdgePosts)
	}
	if m.removedreplies != nil {
		edges = append(edges, post.EdgeReplies)
	}
	if m.removedreplyTo != nil {
		edges = append(edges, post.EdgeReplyTo)
	}
	if m.removedreacts != nil {
		edges = append(edges, post.EdgeReacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.removedcategory))
		for id := range m.removedcategory {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeRoot:
		ids := make([]ent.Value, 0, len(m.removedroot))
		for id := range m.removedroot {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReplyTo:
		ids := make([]ent.Value, 0, len(m.removedreplyTo))
		for id := range m.removedreplyTo {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.removedreacts))
		for id := range m.removedreacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedauthor {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.clearedcategory {
		edges = append(edges, post.EdgeCategory)
	}
	if m.clearedtags {
		edges = append(edges, post.EdgeTags)
	}
	if m.clearedroot {
		edges = append(edges, post.EdgeRoot)
	}
	if m.clearedposts {
		edges = append(edges, post.EdgePosts)
	}
	if m.clearedreplies {
		edges = append(edges, post.EdgeReplies)
	}
	if m.clearedreplyTo {
		edges = append(edges, post.EdgeReplyTo)
	}
	if m.clearedreacts {
		edges = append(edges, post.EdgeReacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeAuthor:
		return m.clearedauthor
	case post.EdgeCategory:
		return m.clearedcategory
	case post.EdgeTags:
		return m.clearedtags
	case post.EdgeRoot:
		return m.clearedroot
	case post.EdgePosts:
		return m.clearedposts
	case post.EdgeReplies:
		return m.clearedreplies
	case post.EdgeReplyTo:
		return m.clearedreplyTo
	case post.EdgeReacts:
		return m.clearedreacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case post.EdgeCategory:
		m.ResetCategory()
		return nil
	case post.EdgeTags:
		m.ResetTags()
		return nil
	case post.EdgeRoot:
		m.ResetRoot()
		return nil
	case post.EdgePosts:
		m.ResetPosts()
		return nil
	case post.EdgeReplies:
		m.ResetReplies()
		return nil
	case post.EdgeReplyTo:
		m.ResetReplyTo()
		return nil
	case post.EdgeReacts:
		m.ResetReacts()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// ReactMutation represents an operation that mutates the React nodes in the graph.
type ReactMutation struct {
	config
	op            Op
	typ           string
	id            *string
	emoji         *string
	createdAt     *time.Time
	postId        *string
	userId        *string
	clearedFields map[string]struct{}
	user          map[uuid.UUID]struct{}
	removeduser   map[uuid.UUID]struct{}
	cleareduser   bool
	_Post         map[uuid.UUID]struct{}
	removed_Post  map[uuid.UUID]struct{}
	cleared_Post  bool
	done          bool
	oldValue      func(context.Context) (*React, error)
	predicates    []predicate.React
}

var _ ent.Mutation = (*ReactMutation)(nil)

// reactOption allows management of the mutation configuration using functional options.
type reactOption func(*ReactMutation)

// newReactMutation creates new mutation for the React entity.
func newReactMutation(c config, op Op, opts ...reactOption) *ReactMutation {
	m := &ReactMutation{
		config:        c,
		op:            op,
		typ:           TypeReact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReactID sets the ID field of the mutation.
func withReactID(id string) reactOption {
	return func(m *ReactMutation) {
		var (
			err   error
			once  sync.Once
			value *React
		)
		m.oldValue = func(ctx context.Context) (*React, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().React.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReact sets the old React of the mutation.
func withReact(node *React) reactOption {
	return func(m *ReactMutation) {
		m.oldValue = func(context.Context) (*React, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of React entities.
func (m *ReactMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReactMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReactMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().React.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmoji sets the "emoji" field.
func (m *ReactMutation) SetEmoji(s string) {
	m.emoji = &s
}

// Emoji returns the value of the "emoji" field in the mutation.
func (m *ReactMutation) Emoji() (r string, exists bool) {
	v := m.emoji
	if v == nil {
		return
	}
	return *v, true
}

// OldEmoji returns the old "emoji" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldEmoji(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmoji is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmoji requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmoji: %w", err)
	}
	return oldValue.Emoji, nil
}

// ResetEmoji resets all changes to the "emoji" field.
func (m *ReactMutation) ResetEmoji() {
	m.emoji = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *ReactMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ReactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ReactMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetPostId sets the "postId" field.
func (m *ReactMutation) SetPostId(s string) {
	m.postId = &s
}

// PostId returns the value of the "postId" field in the mutation.
func (m *ReactMutation) PostId() (r string, exists bool) {
	v := m.postId
	if v == nil {
		return
	}
	return *v, true
}

// OldPostId returns the old "postId" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldPostId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostId: %w", err)
	}
	return oldValue.PostId, nil
}

// ResetPostId resets all changes to the "postId" field.
func (m *ReactMutation) ResetPostId() {
	m.postId = nil
}

// SetUserId sets the "userId" field.
func (m *ReactMutation) SetUserId(s string) {
	m.userId = &s
}

// UserId returns the value of the "userId" field in the mutation.
func (m *ReactMutation) UserId() (r string, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldUserId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *ReactMutation) ResetUserId() {
	m.userId = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *ReactMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.user == nil {
		m.user = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *ReactMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ReactMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *ReactMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removeduser == nil {
		m.removeduser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *ReactMutation) RemovedUserIDs() (ids []uuid.UUID) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *ReactMutation) UserIDs() (ids []uuid.UUID) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ReactMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddPostIDs adds the "Post" edge to the Post entity by ids.
func (m *ReactMutation) AddPostIDs(ids ...uuid.UUID) {
	if m._Post == nil {
		m._Post = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Post[ids[i]] = struct{}{}
	}
}

// ClearPost clears the "Post" edge to the Post entity.
func (m *ReactMutation) ClearPost() {
	m.cleared_Post = true
}

// PostCleared reports if the "Post" edge to the Post entity was cleared.
func (m *ReactMutation) PostCleared() bool {
	return m.cleared_Post
}

// RemovePostIDs removes the "Post" edge to the Post entity by IDs.
func (m *ReactMutation) RemovePostIDs(ids ...uuid.UUID) {
	if m.removed_Post == nil {
		m.removed_Post = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Post, ids[i])
		m.removed_Post[ids[i]] = struct{}{}
	}
}

// RemovedPost returns the removed IDs of the "Post" edge to the Post entity.
func (m *ReactMutation) RemovedPostIDs() (ids []uuid.UUID) {
	for id := range m.removed_Post {
		ids = append(ids, id)
	}
	return
}

// PostIDs returns the "Post" edge IDs in the mutation.
func (m *ReactMutation) PostIDs() (ids []uuid.UUID) {
	for id := range m._Post {
		ids = append(ids, id)
	}
	return
}

// ResetPost resets all changes to the "Post" edge.
func (m *ReactMutation) ResetPost() {
	m._Post = nil
	m.cleared_Post = false
	m.removed_Post = nil
}

// Where appends a list predicates to the ReactMutation builder.
func (m *ReactMutation) Where(ps ...predicate.React) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (React).
func (m *ReactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReactMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.emoji != nil {
		fields = append(fields, react.FieldEmoji)
	}
	if m.createdAt != nil {
		fields = append(fields, react.FieldCreatedAt)
	}
	if m.postId != nil {
		fields = append(fields, react.FieldPostId)
	}
	if m.userId != nil {
		fields = append(fields, react.FieldUserId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case react.FieldEmoji:
		return m.Emoji()
	case react.FieldCreatedAt:
		return m.CreatedAt()
	case react.FieldPostId:
		return m.PostId()
	case react.FieldUserId:
		return m.UserId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case react.FieldEmoji:
		return m.OldEmoji(ctx)
	case react.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case react.FieldPostId:
		return m.OldPostId(ctx)
	case react.FieldUserId:
		return m.OldUserId(ctx)
	}
	return nil, fmt.Errorf("unknown React field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case react.FieldEmoji:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmoji(v)
		return nil
	case react.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case react.FieldPostId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostId(v)
		return nil
	case react.FieldUserId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	}
	return fmt.Errorf("unknown React field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown React numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown React nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReactMutation) ResetField(name string) error {
	switch name {
	case react.FieldEmoji:
		m.ResetEmoji()
		return nil
	case react.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case react.FieldPostId:
		m.ResetPostId()
		return nil
	case react.FieldUserId:
		m.ResetUserId()
		return nil
	}
	return fmt.Errorf("unknown React field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReactMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, react.EdgeUser)
	}
	if m._Post != nil {
		edges = append(edges, react.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case react.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case react.EdgePost:
		ids := make([]ent.Value, 0, len(m._Post))
		for id := range m._Post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, react.EdgeUser)
	}
	if m.removed_Post != nil {
		edges = append(edges, react.EdgePost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case react.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case react.EdgePost:
		ids := make([]ent.Value, 0, len(m.removed_Post))
		for id := range m.removed_Post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, react.EdgeUser)
	}
	if m.cleared_Post {
		edges = append(edges, react.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReactMutation) EdgeCleared(name string) bool {
	switch name {
	case react.EdgeUser:
		return m.cleareduser
	case react.EdgePost:
		return m.cleared_Post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReactMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown React unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReactMutation) ResetEdge(name string) error {
	switch name {
	case react.EdgeUser:
		m.ResetUser()
		return nil
	case react.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown React edge %s", name)
}

// RuleMutation represents an operation that mutates the Rule nodes in the graph.
type RuleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	value          *string
	serverId       *string
	clearedFields  map[string]struct{}
	_Server        map[string]struct{}
	removed_Server map[string]struct{}
	cleared_Server bool
	done           bool
	oldValue       func(context.Context) (*Rule, error)
	predicates     []predicate.Rule
}

var _ ent.Mutation = (*RuleMutation)(nil)

// ruleOption allows management of the mutation configuration using functional options.
type ruleOption func(*RuleMutation)

// newRuleMutation creates new mutation for the Rule entity.
func newRuleMutation(c config, op Op, opts ...ruleOption) *RuleMutation {
	m := &RuleMutation{
		config:        c,
		op:            op,
		typ:           TypeRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleID sets the ID field of the mutation.
func withRuleID(id int) ruleOption {
	return func(m *RuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Rule
		)
		m.oldValue = func(ctx context.Context) (*Rule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRule sets the old Rule of the mutation.
func withRule(node *Rule) ruleOption {
	return func(m *RuleMutation) {
		m.oldValue = func(context.Context) (*Rule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Rule entities.
func (m *RuleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RuleMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *RuleMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RuleMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RuleMutation) ResetValue() {
	m.value = nil
}

// SetServerId sets the "serverId" field.
func (m *RuleMutation) SetServerId(s string) {
	m.serverId = &s
}

// ServerId returns the value of the "serverId" field in the mutation.
func (m *RuleMutation) ServerId() (r string, exists bool) {
	v := m.serverId
	if v == nil {
		return
	}
	return *v, true
}

// OldServerId returns the old "serverId" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldServerId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerId: %w", err)
	}
	return oldValue.ServerId, nil
}

// ClearServerId clears the value of the "serverId" field.
func (m *RuleMutation) ClearServerId() {
	m.serverId = nil
	m.clearedFields[rule.FieldServerId] = struct{}{}
}

// ServerIdCleared returns if the "serverId" field was cleared in this mutation.
func (m *RuleMutation) ServerIdCleared() bool {
	_, ok := m.clearedFields[rule.FieldServerId]
	return ok
}

// ResetServerId resets all changes to the "serverId" field.
func (m *RuleMutation) ResetServerId() {
	m.serverId = nil
	delete(m.clearedFields, rule.FieldServerId)
}

// AddServerIDs adds the "Server" edge to the Server entity by ids.
func (m *RuleMutation) AddServerIDs(ids ...string) {
	if m._Server == nil {
		m._Server = make(map[string]struct{})
	}
	for i := range ids {
		m._Server[ids[i]] = struct{}{}
	}
}

// ClearServer clears the "Server" edge to the Server entity.
func (m *RuleMutation) ClearServer() {
	m.cleared_Server = true
}

// ServerCleared reports if the "Server" edge to the Server entity was cleared.
func (m *RuleMutation) ServerCleared() bool {
	return m.cleared_Server
}

// RemoveServerIDs removes the "Server" edge to the Server entity by IDs.
func (m *RuleMutation) RemoveServerIDs(ids ...string) {
	if m.removed_Server == nil {
		m.removed_Server = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._Server, ids[i])
		m.removed_Server[ids[i]] = struct{}{}
	}
}

// RemovedServer returns the removed IDs of the "Server" edge to the Server entity.
func (m *RuleMutation) RemovedServerIDs() (ids []string) {
	for id := range m.removed_Server {
		ids = append(ids, id)
	}
	return
}

// ServerIDs returns the "Server" edge IDs in the mutation.
func (m *RuleMutation) ServerIDs() (ids []string) {
	for id := range m._Server {
		ids = append(ids, id)
	}
	return
}

// ResetServer resets all changes to the "Server" edge.
func (m *RuleMutation) ResetServer() {
	m._Server = nil
	m.cleared_Server = false
	m.removed_Server = nil
}

// Where appends a list predicates to the RuleMutation builder.
func (m *RuleMutation) Where(ps ...predicate.Rule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Rule).
func (m *RuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RuleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, rule.FieldName)
	}
	if m.value != nil {
		fields = append(fields, rule.FieldValue)
	}
	if m.serverId != nil {
		fields = append(fields, rule.FieldServerId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rule.FieldName:
		return m.Name()
	case rule.FieldValue:
		return m.Value()
	case rule.FieldServerId:
		return m.ServerId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rule.FieldName:
		return m.OldName(ctx)
	case rule.FieldValue:
		return m.OldValue(ctx)
	case rule.FieldServerId:
		return m.OldServerId(ctx)
	}
	return nil, fmt.Errorf("unknown Rule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rule.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case rule.FieldServerId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerId(v)
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rule.FieldServerId) {
		fields = append(fields, rule.FieldServerId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleMutation) ClearField(name string) error {
	switch name {
	case rule.FieldServerId:
		m.ClearServerId()
		return nil
	}
	return fmt.Errorf("unknown Rule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RuleMutation) ResetField(name string) error {
	switch name {
	case rule.FieldName:
		m.ResetName()
		return nil
	case rule.FieldValue:
		m.ResetValue()
		return nil
	case rule.FieldServerId:
		m.ResetServerId()
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Server != nil {
		edges = append(edges, rule.EdgeServer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeServer:
		ids := make([]ent.Value, 0, len(m._Server))
		for id := range m._Server {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Server != nil {
		edges = append(edges, rule.EdgeServer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeServer:
		ids := make([]ent.Value, 0, len(m.removed_Server))
		for id := range m.removed_Server {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Server {
		edges = append(edges, rule.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RuleMutation) EdgeCleared(name string) bool {
	switch name {
	case rule.EdgeServer:
		return m.cleared_Server
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Rule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RuleMutation) ResetEdge(name string) error {
	switch name {
	case rule.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown Rule edge %s", name)
}

// ServerMutation represents an operation that mutates the Server nodes in the graph.
type ServerMutation struct {
	config
	op            Op
	typ           string
	id            *string
	ip            *string
	hn            *string
	pc            *int
	addpc         *int
	pm            *int
	addpm         *int
	gm            *string
	la            *string
	pa            *bool
	vn            *string
	domain        *string
	description   *string
	banner        *string
	userId        *string
	active        *bool
	updatedAt     *time.Time
	deletedAt     *time.Time
	clearedFields map[string]struct{}
	ru            map[int]struct{}
	removedru     map[int]struct{}
	clearedru     bool
	_User         map[uuid.UUID]struct{}
	removed_User  map[uuid.UUID]struct{}
	cleared_User  bool
	done          bool
	oldValue      func(context.Context) (*Server, error)
	predicates    []predicate.Server
}

var _ ent.Mutation = (*ServerMutation)(nil)

// serverOption allows management of the mutation configuration using functional options.
type serverOption func(*ServerMutation)

// newServerMutation creates new mutation for the Server entity.
func newServerMutation(c config, op Op, opts ...serverOption) *ServerMutation {
	m := &ServerMutation{
		config:        c,
		op:            op,
		typ:           TypeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerID sets the ID field of the mutation.
func withServerID(id string) serverOption {
	return func(m *ServerMutation) {
		var (
			err   error
			once  sync.Once
			value *Server
		)
		m.oldValue = func(ctx context.Context) (*Server, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Server.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServer sets the old Server of the mutation.
func withServer(node *Server) serverOption {
	return func(m *ServerMutation) {
		m.oldValue = func(context.Context) (*Server, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Server entities.
func (m *ServerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Server.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIP sets the "ip" field.
func (m *ServerMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *ServerMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *ServerMutation) ResetIP() {
	m.ip = nil
}

// SetHn sets the "hn" field.
func (m *ServerMutation) SetHn(s string) {
	m.hn = &s
}

// Hn returns the value of the "hn" field in the mutation.
func (m *ServerMutation) Hn() (r string, exists bool) {
	v := m.hn
	if v == nil {
		return
	}
	return *v, true
}

// OldHn returns the old "hn" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldHn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHn: %w", err)
	}
	return oldValue.Hn, nil
}

// ResetHn resets all changes to the "hn" field.
func (m *ServerMutation) ResetHn() {
	m.hn = nil
}

// SetPc sets the "pc" field.
func (m *ServerMutation) SetPc(i int) {
	m.pc = &i
	m.addpc = nil
}

// Pc returns the value of the "pc" field in the mutation.
func (m *ServerMutation) Pc() (r int, exists bool) {
	v := m.pc
	if v == nil {
		return
	}
	return *v, true
}

// OldPc returns the old "pc" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldPc(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPc: %w", err)
	}
	return oldValue.Pc, nil
}

// AddPc adds i to the "pc" field.
func (m *ServerMutation) AddPc(i int) {
	if m.addpc != nil {
		*m.addpc += i
	} else {
		m.addpc = &i
	}
}

// AddedPc returns the value that was added to the "pc" field in this mutation.
func (m *ServerMutation) AddedPc() (r int, exists bool) {
	v := m.addpc
	if v == nil {
		return
	}
	return *v, true
}

// ResetPc resets all changes to the "pc" field.
func (m *ServerMutation) ResetPc() {
	m.pc = nil
	m.addpc = nil
}

// SetPm sets the "pm" field.
func (m *ServerMutation) SetPm(i int) {
	m.pm = &i
	m.addpm = nil
}

// Pm returns the value of the "pm" field in the mutation.
func (m *ServerMutation) Pm() (r int, exists bool) {
	v := m.pm
	if v == nil {
		return
	}
	return *v, true
}

// OldPm returns the old "pm" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldPm(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPm: %w", err)
	}
	return oldValue.Pm, nil
}

// AddPm adds i to the "pm" field.
func (m *ServerMutation) AddPm(i int) {
	if m.addpm != nil {
		*m.addpm += i
	} else {
		m.addpm = &i
	}
}

// AddedPm returns the value that was added to the "pm" field in this mutation.
func (m *ServerMutation) AddedPm() (r int, exists bool) {
	v := m.addpm
	if v == nil {
		return
	}
	return *v, true
}

// ResetPm resets all changes to the "pm" field.
func (m *ServerMutation) ResetPm() {
	m.pm = nil
	m.addpm = nil
}

// SetGm sets the "gm" field.
func (m *ServerMutation) SetGm(s string) {
	m.gm = &s
}

// Gm returns the value of the "gm" field in the mutation.
func (m *ServerMutation) Gm() (r string, exists bool) {
	v := m.gm
	if v == nil {
		return
	}
	return *v, true
}

// OldGm returns the old "gm" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldGm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGm: %w", err)
	}
	return oldValue.Gm, nil
}

// ResetGm resets all changes to the "gm" field.
func (m *ServerMutation) ResetGm() {
	m.gm = nil
}

// SetLa sets the "la" field.
func (m *ServerMutation) SetLa(s string) {
	m.la = &s
}

// La returns the value of the "la" field in the mutation.
func (m *ServerMutation) La() (r string, exists bool) {
	v := m.la
	if v == nil {
		return
	}
	return *v, true
}

// OldLa returns the old "la" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldLa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLa: %w", err)
	}
	return oldValue.La, nil
}

// ResetLa resets all changes to the "la" field.
func (m *ServerMutation) ResetLa() {
	m.la = nil
}

// SetPa sets the "pa" field.
func (m *ServerMutation) SetPa(b bool) {
	m.pa = &b
}

// Pa returns the value of the "pa" field in the mutation.
func (m *ServerMutation) Pa() (r bool, exists bool) {
	v := m.pa
	if v == nil {
		return
	}
	return *v, true
}

// OldPa returns the old "pa" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldPa(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPa: %w", err)
	}
	return oldValue.Pa, nil
}

// ResetPa resets all changes to the "pa" field.
func (m *ServerMutation) ResetPa() {
	m.pa = nil
}

// SetVn sets the "vn" field.
func (m *ServerMutation) SetVn(s string) {
	m.vn = &s
}

// Vn returns the value of the "vn" field in the mutation.
func (m *ServerMutation) Vn() (r string, exists bool) {
	v := m.vn
	if v == nil {
		return
	}
	return *v, true
}

// OldVn returns the old "vn" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldVn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVn: %w", err)
	}
	return oldValue.Vn, nil
}

// ResetVn resets all changes to the "vn" field.
func (m *ServerMutation) ResetVn() {
	m.vn = nil
}

// SetDomain sets the "domain" field.
func (m *ServerMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *ServerMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *ServerMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[server.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *ServerMutation) DomainCleared() bool {
	_, ok := m.clearedFields[server.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *ServerMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, server.FieldDomain)
}

// SetDescription sets the "description" field.
func (m *ServerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[server.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[server.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, server.FieldDescription)
}

// SetBanner sets the "banner" field.
func (m *ServerMutation) SetBanner(s string) {
	m.banner = &s
}

// Banner returns the value of the "banner" field in the mutation.
func (m *ServerMutation) Banner() (r string, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBanner returns the old "banner" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldBanner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanner: %w", err)
	}
	return oldValue.Banner, nil
}

// ClearBanner clears the value of the "banner" field.
func (m *ServerMutation) ClearBanner() {
	m.banner = nil
	m.clearedFields[server.FieldBanner] = struct{}{}
}

// BannerCleared returns if the "banner" field was cleared in this mutation.
func (m *ServerMutation) BannerCleared() bool {
	_, ok := m.clearedFields[server.FieldBanner]
	return ok
}

// ResetBanner resets all changes to the "banner" field.
func (m *ServerMutation) ResetBanner() {
	m.banner = nil
	delete(m.clearedFields, server.FieldBanner)
}

// SetUserId sets the "userId" field.
func (m *ServerMutation) SetUserId(s string) {
	m.userId = &s
}

// UserId returns the value of the "userId" field in the mutation.
func (m *ServerMutation) UserId() (r string, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldUserId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "userId" field.
func (m *ServerMutation) ClearUserId() {
	m.userId = nil
	m.clearedFields[server.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *ServerMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[server.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *ServerMutation) ResetUserId() {
	m.userId = nil
	delete(m.clearedFields, server.FieldUserId)
}

// SetActive sets the "active" field.
func (m *ServerMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ServerMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ServerMutation) ResetActive() {
	m.active = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ServerMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ServerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ServerMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *ServerMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *ServerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *ServerMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[server.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *ServerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[server.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *ServerMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, server.FieldDeletedAt)
}

// AddRuIDs adds the "ru" edge to the Rule entity by ids.
func (m *ServerMutation) AddRuIDs(ids ...int) {
	if m.ru == nil {
		m.ru = make(map[int]struct{})
	}
	for i := range ids {
		m.ru[ids[i]] = struct{}{}
	}
}

// ClearRu clears the "ru" edge to the Rule entity.
func (m *ServerMutation) ClearRu() {
	m.clearedru = true
}

// RuCleared reports if the "ru" edge to the Rule entity was cleared.
func (m *ServerMutation) RuCleared() bool {
	return m.clearedru
}

// RemoveRuIDs removes the "ru" edge to the Rule entity by IDs.
func (m *ServerMutation) RemoveRuIDs(ids ...int) {
	if m.removedru == nil {
		m.removedru = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ru, ids[i])
		m.removedru[ids[i]] = struct{}{}
	}
}

// RemovedRu returns the removed IDs of the "ru" edge to the Rule entity.
func (m *ServerMutation) RemovedRuIDs() (ids []int) {
	for id := range m.removedru {
		ids = append(ids, id)
	}
	return
}

// RuIDs returns the "ru" edge IDs in the mutation.
func (m *ServerMutation) RuIDs() (ids []int) {
	for id := range m.ru {
		ids = append(ids, id)
	}
	return
}

// ResetRu resets all changes to the "ru" edge.
func (m *ServerMutation) ResetRu() {
	m.ru = nil
	m.clearedru = false
	m.removedru = nil
}

// AddUserIDs adds the "User" edge to the User entity by ids.
func (m *ServerMutation) AddUserIDs(ids ...uuid.UUID) {
	if m._User == nil {
		m._User = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._User[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "User" edge to the User entity.
func (m *ServerMutation) ClearUser() {
	m.cleared_User = true
}

// UserCleared reports if the "User" edge to the User entity was cleared.
func (m *ServerMutation) UserCleared() bool {
	return m.cleared_User
}

// RemoveUserIDs removes the "User" edge to the User entity by IDs.
func (m *ServerMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removed_User == nil {
		m.removed_User = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._User, ids[i])
		m.removed_User[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "User" edge to the User entity.
func (m *ServerMutation) RemovedUserIDs() (ids []uuid.UUID) {
	for id := range m.removed_User {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
func (m *ServerMutation) UserIDs() (ids []uuid.UUID) {
	for id := range m._User {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *ServerMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
	m.removed_User = nil
}

// Where appends a list predicates to the ServerMutation builder.
func (m *ServerMutation) Where(ps ...predicate.Server) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ServerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Server).
func (m *ServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.ip != nil {
		fields = append(fields, server.FieldIP)
	}
	if m.hn != nil {
		fields = append(fields, server.FieldHn)
	}
	if m.pc != nil {
		fields = append(fields, server.FieldPc)
	}
	if m.pm != nil {
		fields = append(fields, server.FieldPm)
	}
	if m.gm != nil {
		fields = append(fields, server.FieldGm)
	}
	if m.la != nil {
		fields = append(fields, server.FieldLa)
	}
	if m.pa != nil {
		fields = append(fields, server.FieldPa)
	}
	if m.vn != nil {
		fields = append(fields, server.FieldVn)
	}
	if m.domain != nil {
		fields = append(fields, server.FieldDomain)
	}
	if m.description != nil {
		fields = append(fields, server.FieldDescription)
	}
	if m.banner != nil {
		fields = append(fields, server.FieldBanner)
	}
	if m.userId != nil {
		fields = append(fields, server.FieldUserId)
	}
	if m.active != nil {
		fields = append(fields, server.FieldActive)
	}
	if m.updatedAt != nil {
		fields = append(fields, server.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, server.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case server.FieldIP:
		return m.IP()
	case server.FieldHn:
		return m.Hn()
	case server.FieldPc:
		return m.Pc()
	case server.FieldPm:
		return m.Pm()
	case server.FieldGm:
		return m.Gm()
	case server.FieldLa:
		return m.La()
	case server.FieldPa:
		return m.Pa()
	case server.FieldVn:
		return m.Vn()
	case server.FieldDomain:
		return m.Domain()
	case server.FieldDescription:
		return m.Description()
	case server.FieldBanner:
		return m.Banner()
	case server.FieldUserId:
		return m.UserId()
	case server.FieldActive:
		return m.Active()
	case server.FieldUpdatedAt:
		return m.UpdatedAt()
	case server.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case server.FieldIP:
		return m.OldIP(ctx)
	case server.FieldHn:
		return m.OldHn(ctx)
	case server.FieldPc:
		return m.OldPc(ctx)
	case server.FieldPm:
		return m.OldPm(ctx)
	case server.FieldGm:
		return m.OldGm(ctx)
	case server.FieldLa:
		return m.OldLa(ctx)
	case server.FieldPa:
		return m.OldPa(ctx)
	case server.FieldVn:
		return m.OldVn(ctx)
	case server.FieldDomain:
		return m.OldDomain(ctx)
	case server.FieldDescription:
		return m.OldDescription(ctx)
	case server.FieldBanner:
		return m.OldBanner(ctx)
	case server.FieldUserId:
		return m.OldUserId(ctx)
	case server.FieldActive:
		return m.OldActive(ctx)
	case server.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case server.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Server field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case server.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case server.FieldHn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHn(v)
		return nil
	case server.FieldPc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPc(v)
		return nil
	case server.FieldPm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPm(v)
		return nil
	case server.FieldGm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGm(v)
		return nil
	case server.FieldLa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLa(v)
		return nil
	case server.FieldPa:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPa(v)
		return nil
	case server.FieldVn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVn(v)
		return nil
	case server.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case server.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case server.FieldBanner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanner(v)
		return nil
	case server.FieldUserId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case server.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case server.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case server.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMutation) AddedFields() []string {
	var fields []string
	if m.addpc != nil {
		fields = append(fields, server.FieldPc)
	}
	if m.addpm != nil {
		fields = append(fields, server.FieldPm)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case server.FieldPc:
		return m.AddedPc()
	case server.FieldPm:
		return m.AddedPm()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case server.FieldPc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPc(v)
		return nil
	case server.FieldPm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPm(v)
		return nil
	}
	return fmt.Errorf("unknown Server numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(server.FieldDomain) {
		fields = append(fields, server.FieldDomain)
	}
	if m.FieldCleared(server.FieldDescription) {
		fields = append(fields, server.FieldDescription)
	}
	if m.FieldCleared(server.FieldBanner) {
		fields = append(fields, server.FieldBanner)
	}
	if m.FieldCleared(server.FieldUserId) {
		fields = append(fields, server.FieldUserId)
	}
	if m.FieldCleared(server.FieldDeletedAt) {
		fields = append(fields, server.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMutation) ClearField(name string) error {
	switch name {
	case server.FieldDomain:
		m.ClearDomain()
		return nil
	case server.FieldDescription:
		m.ClearDescription()
		return nil
	case server.FieldBanner:
		m.ClearBanner()
		return nil
	case server.FieldUserId:
		m.ClearUserId()
		return nil
	case server.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Server nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMutation) ResetField(name string) error {
	switch name {
	case server.FieldIP:
		m.ResetIP()
		return nil
	case server.FieldHn:
		m.ResetHn()
		return nil
	case server.FieldPc:
		m.ResetPc()
		return nil
	case server.FieldPm:
		m.ResetPm()
		return nil
	case server.FieldGm:
		m.ResetGm()
		return nil
	case server.FieldLa:
		m.ResetLa()
		return nil
	case server.FieldPa:
		m.ResetPa()
		return nil
	case server.FieldVn:
		m.ResetVn()
		return nil
	case server.FieldDomain:
		m.ResetDomain()
		return nil
	case server.FieldDescription:
		m.ResetDescription()
		return nil
	case server.FieldBanner:
		m.ResetBanner()
		return nil
	case server.FieldUserId:
		m.ResetUserId()
		return nil
	case server.FieldActive:
		m.ResetActive()
		return nil
	case server.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case server.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ru != nil {
		edges = append(edges, server.EdgeRu)
	}
	if m._User != nil {
		edges = append(edges, server.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeRu:
		ids := make([]ent.Value, 0, len(m.ru))
		for id := range m.ru {
			ids = append(ids, id)
		}
		return ids
	case server.EdgeUser:
		ids := make([]ent.Value, 0, len(m._User))
		for id := range m._User {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedru != nil {
		edges = append(edges, server.EdgeRu)
	}
	if m.removed_User != nil {
		edges = append(edges, server.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeRu:
		ids := make([]ent.Value, 0, len(m.removedru))
		for id := range m.removedru {
			ids = append(ids, id)
		}
		return ids
	case server.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removed_User))
		for id := range m.removed_User {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedru {
		edges = append(edges, server.EdgeRu)
	}
	if m.cleared_User {
		edges = append(edges, server.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMutation) EdgeCleared(name string) bool {
	switch name {
	case server.EdgeRu:
		return m.clearedru
	case server.EdgeUser:
		return m.cleared_User
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Server unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMutation) ResetEdge(name string) error {
	switch name {
	case server.EdgeRu:
		m.ResetRu()
		return nil
	case server.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Server edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	refersType           *subscription.RefersType
	refersTo             *string
	createdAt            *time.Time
	updatedAt            *time.Time
	deletedAt            *time.Time
	userId               *string
	clearedFields        map[string]struct{}
	user                 map[uuid.UUID]struct{}
	removeduser          map[uuid.UUID]struct{}
	cleareduser          bool
	notifications        map[string]struct{}
	removednotifications map[string]struct{}
	clearednotifications bool
	done                 bool
	oldValue             func(context.Context) (*Subscription, error)
	predicates           []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id string) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscription entities.
func (m *SubscriptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRefersType sets the "refersType" field.
func (m *SubscriptionMutation) SetRefersType(st subscription.RefersType) {
	m.refersType = &st
}

// RefersType returns the value of the "refersType" field in the mutation.
func (m *SubscriptionMutation) RefersType() (r subscription.RefersType, exists bool) {
	v := m.refersType
	if v == nil {
		return
	}
	return *v, true
}

// OldRefersType returns the old "refersType" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldRefersType(ctx context.Context) (v subscription.RefersType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefersType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefersType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefersType: %w", err)
	}
	return oldValue.RefersType, nil
}

// ResetRefersType resets all changes to the "refersType" field.
func (m *SubscriptionMutation) ResetRefersType() {
	m.refersType = nil
}

// SetRefersTo sets the "refersTo" field.
func (m *SubscriptionMutation) SetRefersTo(s string) {
	m.refersTo = &s
}

// RefersTo returns the value of the "refersTo" field in the mutation.
func (m *SubscriptionMutation) RefersTo() (r string, exists bool) {
	v := m.refersTo
	if v == nil {
		return
	}
	return *v, true
}

// OldRefersTo returns the old "refersTo" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldRefersTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefersTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefersTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefersTo: %w", err)
	}
	return oldValue.RefersTo, nil
}

// ResetRefersTo resets all changes to the "refersTo" field.
func (m *SubscriptionMutation) ResetRefersTo() {
	m.refersTo = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *SubscriptionMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *SubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *SubscriptionMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *SubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *SubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *SubscriptionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *SubscriptionMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *SubscriptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *SubscriptionMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[subscription.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *SubscriptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *SubscriptionMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, subscription.FieldDeletedAt)
}

// SetUserId sets the "userId" field.
func (m *SubscriptionMutation) SetUserId(s string) {
	m.userId = &s
}

// UserId returns the value of the "userId" field in the mutation.
func (m *SubscriptionMutation) UserId() (r string, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUserId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *SubscriptionMutation) ResetUserId() {
	m.userId = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *SubscriptionMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.user == nil {
		m.user = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *SubscriptionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *SubscriptionMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removeduser == nil {
		m.removeduser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *SubscriptionMutation) RemovedUserIDs() (ids []uuid.UUID) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *SubscriptionMutation) UserIDs() (ids []uuid.UUID) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *SubscriptionMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *SubscriptionMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *SubscriptionMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *SubscriptionMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *SubscriptionMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *SubscriptionMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *SubscriptionMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.refersType != nil {
		fields = append(fields, subscription.FieldRefersType)
	}
	if m.refersTo != nil {
		fields = append(fields, subscription.FieldRefersTo)
	}
	if m.createdAt != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, subscription.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	if m.userId != nil {
		fields = append(fields, subscription.FieldUserId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldRefersType:
		return m.RefersType()
	case subscription.FieldRefersTo:
		return m.RefersTo()
	case subscription.FieldCreatedAt:
		return m.CreatedAt()
	case subscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscription.FieldDeletedAt:
		return m.DeletedAt()
	case subscription.FieldUserId:
		return m.UserId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldRefersType:
		return m.OldRefersType(ctx)
	case subscription.FieldRefersTo:
		return m.OldRefersTo(ctx)
	case subscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscription.FieldUserId:
		return m.OldUserId(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldRefersType:
		v, ok := value.(subscription.RefersType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefersType(v)
		return nil
	case subscription.FieldRefersTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefersTo(v)
		return nil
	case subscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscription.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscription.FieldUserId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldDeletedAt) {
		fields = append(fields, subscription.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldRefersType:
		m.ResetRefersType()
		return nil
	case subscription.FieldRefersTo:
		m.ResetRefersTo()
		return nil
	case subscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscription.FieldUserId:
		m.ResetUserId()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.notifications != nil {
		edges = append(edges, subscription.EdgeNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.removednotifications != nil {
		edges = append(edges, subscription.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case subscription.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.clearednotifications {
		edges = append(edges, subscription.EdgeNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgeUser:
		return m.cleareduser
	case subscription.EdgeNotifications:
		return m.clearednotifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ResetUser()
		return nil
	case subscription.EdgeNotifications:
		m.ResetNotifications()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	clearedFields map[string]struct{}
	posts         map[uuid.UUID]struct{}
	removedposts  map[uuid.UUID]struct{}
	clearedposts  bool
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *TagMutation) AddPostIDs(ids ...uuid.UUID) {
	if m.posts == nil {
		m.posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *TagMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *TagMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *TagMutation) RemovePostIDs(ids ...uuid.UUID) {
	if m.removedposts == nil {
		m.removedposts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *TagMutation) RemovedPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *TagMutation) PostsIDs() (ids []uuid.UUID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *TagMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.posts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedposts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedposts {
		edges = append(edges, tag.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	email                *string
	name                 *string
	bio                  *string
	admin                *bool
	createdAt            *time.Time
	updatedAt            *time.Time
	deletedAt            *time.Time
	clearedFields        map[string]struct{}
	posts                map[uuid.UUID]struct{}
	removedposts         map[uuid.UUID]struct{}
	clearedposts         bool
	reacts               map[string]struct{}
	removedreacts        map[string]struct{}
	clearedreacts        bool
	subscriptions        map[string]struct{}
	removedsubscriptions map[string]struct{}
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetAdmin sets the "admin" field.
func (m *UserMutation) SetAdmin(b bool) {
	m.admin = &b
}

// Admin returns the value of the "admin" field in the mutation.
func (m *UserMutation) Admin() (r bool, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "admin" field.
func (m *UserMutation) ResetAdmin() {
	m.admin = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetDeletedAt sets the "deletedAt" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deletedAt = &t
}

// DeletedAt returns the value of the "deletedAt" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deletedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deletedAt" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deletedAt = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deletedAt" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deletedAt" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deletedAt = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *UserMutation) AddPostIDs(ids ...uuid.UUID) {
	if m.posts == nil {
		m.posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *UserMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *UserMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *UserMutation) RemovePostIDs(ids ...uuid.UUID) {
	if m.removedposts == nil {
		m.removedposts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *UserMutation) RemovedPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *UserMutation) PostsIDs() (ids []uuid.UUID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *UserMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddReactIDs adds the "reacts" edge to the React entity by ids.
func (m *UserMutation) AddReactIDs(ids ...string) {
	if m.reacts == nil {
		m.reacts = make(map[string]struct{})
	}
	for i := range ids {
		m.reacts[ids[i]] = struct{}{}
	}
}

// ClearReacts clears the "reacts" edge to the React entity.
func (m *UserMutation) ClearReacts() {
	m.clearedreacts = true
}

// ReactsCleared reports if the "reacts" edge to the React entity was cleared.
func (m *UserMutation) ReactsCleared() bool {
	return m.clearedreacts
}

// RemoveReactIDs removes the "reacts" edge to the React entity by IDs.
func (m *UserMutation) RemoveReactIDs(ids ...string) {
	if m.removedreacts == nil {
		m.removedreacts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reacts, ids[i])
		m.removedreacts[ids[i]] = struct{}{}
	}
}

// RemovedReacts returns the removed IDs of the "reacts" edge to the React entity.
func (m *UserMutation) RemovedReactsIDs() (ids []string) {
	for id := range m.removedreacts {
		ids = append(ids, id)
	}
	return
}

// ReactsIDs returns the "reacts" edge IDs in the mutation.
func (m *UserMutation) ReactsIDs() (ids []string) {
	for id := range m.reacts {
		ids = append(ids, id)
	}
	return
}

// ResetReacts resets all changes to the "reacts" edge.
func (m *UserMutation) ResetReacts() {
	m.reacts = nil
	m.clearedreacts = false
	m.removedreacts = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[string]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []string) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []string) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.admin != nil {
		fields = append(fields, user.FieldAdmin)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deletedAt != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldBio:
		return m.Bio()
	case user.FieldAdmin:
		return m.Admin()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldAdmin:
		return m.OldAdmin(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldAdmin:
		m.ResetAdmin()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.posts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.reacts != nil {
		edges = append(edges, user.EdgeReacts)
	}
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.reacts))
		for id := range m.reacts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedposts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.removedreacts != nil {
		edges = append(edges, user.EdgeReacts)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.removedreacts))
		for id := range m.removedreacts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedposts {
		edges = append(edges, user.EdgePosts)
	}
	if m.clearedreacts {
		edges = append(edges, user.EdgeReacts)
	}
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePosts:
		return m.clearedposts
	case user.EdgeReacts:
		return m.clearedreacts
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePosts:
		m.ResetPosts()
		return nil
	case user.EdgeReacts:
		m.ResetReacts()
		return nil
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
